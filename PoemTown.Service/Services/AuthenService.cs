using AutoMapper;
using MassTransit;
using Microsoft.AspNetCore.Identity;
using PoemTown.Repository.Entities;
using PoemTown.Repository.Interfaces;
using PoemTown.Service.Interfaces;
using Microsoft.AspNetCore.Http;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using PoemTown.Repository.CustomException;
using PoemTown.Repository.Enums;
using PoemTown.Repository.Enums.Accounts;
using PoemTown.Repository.Utils;
using PoemTown.Service.BusinessModels.RequestModels.AuthenticationRequests;
using PoemTown.Service.BusinessModels.ResponseModels.AuthenResponses;
using PoemTown.Service.BusinessModels.ResponseModels.TokenResponses;
using PoemTown.Service.Events.AuthenticationEvents;
using PoemTown.Service.Events.EmailEvents;

namespace PoemTown.Service.Services
{
    public class AuthenService : IAuthenService
    {
        private readonly UserManager<User> _userManager;
        private readonly SignInManager<User> _signInManager;
        private readonly IUnitOfWork _unitOfWork;
        private readonly ITokenService _tokenService;
        private readonly IPublishEndpoint _publishEndpoint;
        private readonly RoleManager<Role> _roleManager;
        private readonly IMapper _mapper;
        private readonly ILogger<AuthenService> _logger;

        public AuthenService(
            UserManager<User> userManager,
            IUnitOfWork unitOfWork,
            SignInManager<User> signInManager,
            ITokenService tokenService,
            IPublishEndpoint publishEndpoint,
            RoleManager<Role> roleManager,
            IMapper mapper,
            ILogger<AuthenService> logger
            )
        {
            _userManager = userManager;
            _unitOfWork = unitOfWork;
            _signInManager = signInManager;
            _tokenService = tokenService;
            _publishEndpoint = publishEndpoint;
            _roleManager = roleManager;
            _mapper = mapper;
            _logger = logger;
        }
        /// <summary>
        /// Login and return AccessToken and RefreshToken by JWT, need to verify user password (get from request) with salt (get from database)
        /// by hash them and compare with identity password function
        /// </summary>
        /// Also need to verify email is confirmed
        /// <summary>
        /// </summary>
        /// <param name="request"><see cref="LoginRequest"/></param>
        /// <param name="userAgent">The current browser user using</param>
        /// <param name="ipAddress">The current user's ipaddress</param>
        /// <returns><see cref="LoginResponse"/></returns>
        /// <exception cref="CoreException"></exception>
        public async Task<LoginResponse> Login(LoginRequest request, string userAgent, string ipAddress)
        {
            User? user = await _unitOfWork.GetRepository<User>().FindAsync(p => p.Email == request.Email);
            if (user == null)
            {
                throw new CoreException(StatusCodes.Status401Unauthorized, "User not found");
            }

            //check if email is confirmed
            if (!await _userManager.IsEmailConfirmedAsync(user))
            {
                throw new CoreException(StatusCodes.Status401Unauthorized, "Email is not confirmed");
            }

            switch (user.Status)
            {
                case AccountStatus.Locked:
                    throw new CoreException(StatusCodes.Status401Unauthorized, "Account is locked, please contact admin");
                case AccountStatus.InActive:
                    throw new CoreException(StatusCodes.Status401Unauthorized, "Account is inactive");
            }
            
            /*if(!PasswordHasher.VerifyPassword(request.Password, user.PasswordHash, user.Salt))
            {
                _signInManager.CheckPasswordSignInAsync()
                throw new CoreException(StatusCodes.Status400BadRequest, "Password is incorrect");
            }*/

            //get salt from database
            string? salt = await _unitOfWork.GetRepository<User>()
                .AsQueryable()
                .Where(p => p.Email == request.Email)
                .Select(p => p.Salt)
                .FirstOrDefaultAsync();
            
            if (salt == null)
            {
                throw new CoreException(StatusCodes.Status400BadRequest, "Salt not found");
            }
            
            //hash password with salt
            string hashedPassword = PasswordHasher.HashPassword(request.Password, salt);
            //check if hashedPassword with salt is equal to passwordHash in database by identity (hashedPassword in database is generated by identity)
            
            var resultSucceeded = await _signInManager.CheckPasswordSignInAsync(user, hashedPassword, true);
            if (!resultSucceeded.Succeeded)
            {
                throw new CoreException(StatusCodes.Status401Unauthorized, "Password is incorrect");
            }

            var signInResult = await _signInManager.PasswordSignInAsync(user, hashedPassword, true, false);
            //check if login success
            if (!signInResult.Succeeded)
            {
                throw new CoreException(StatusCodes.Status401Unauthorized, "Login failed");
            }

            // Tracking user login by date
            await _publishEndpoint.Publish(new TrackingUserLoginEvent()
            {
                UserId = user.Id,
            });
            
            //generate token
            var token = await _tokenService.GenerateTokens(user, userAgent, ipAddress);
            
            return new LoginResponse()
            {
                AccessToken = token.AccessToken,
                RefreshToken = token.RefreshToken,
                Role = await _userManager.GetRolesAsync(user)
            };

            
            
        }


        public async Task RegisterAccount(RegisterRequest request)
        {
            User user = await _unitOfWork.GetRepository<User>()
                .FindAsync(p => p.Email.Equals(request.Email) || p.UserName.Equals(request.UserName));
            
            if (user != null && user.GoogleId == null)
            {
                throw new CoreException(StatusCodes.Status400BadRequest, "User already exists");
            }

            var roleName = StringHelper.CapitalizeString("user");
            //Get role by identity role (_roleManager)
            var role = await _roleManager.FindByNameAsync(roleName);
            if (role == null)
            {
                throw new CoreException(StatusCodes.Status400BadRequest, "Role not found");
            }

            //Generate salt and hash password with salt
            string salt = PasswordHasher.GenerateSalt();
            string hashedPassword = PasswordHasher.HashPassword(request.Password, salt);
            string emailOtp = OtpGenerator.GenerateOtp();
            string emailOtpExpiration = TimeStampHelper.GenerateUnixTimeStamp(0, 10, 0).ToString();

            User newUser = new User()
            {
                UserName = request.UserName,
                Email = request.Email,
                PhoneNumber = request.PhoneNumber,
                FullName = request.FullName,
                DisplayName = request.FullName,
                CreatedBy = "System",
                LastUpdatedBy = "System",
                Salt = salt,
                PasswordHash = hashedPassword,
                EmailOtp = emailOtp,
                EmailOtpExpiration = emailOtpExpiration,
                Address = request.Address,
                Gender = request.Gender,
                DateOfBirth = request.DateOfBirth,
                Status = AccountStatus.InActive
            };
            
            //If user first register as google account, then transfer data to identity user
            if (user != null && user.GoogleId != null)
            {
                var addPasswordResult = await _userManager.AddPasswordAsync(user, newUser.PasswordHash);
                user.PhoneNumber = newUser.PhoneNumber;
                user.FullName = newUser.FullName;
                user.DisplayName = newUser.DisplayName;
                user.CreatedBy = newUser.CreatedBy;
                user.LastUpdatedBy = newUser.LastUpdatedBy;
                user.Salt = newUser.Salt;
                user.EmailOtp = newUser.EmailOtp;
                user.EmailOtpExpiration = newUser.EmailOtpExpiration;
                user.Address = newUser.Address;
                user.Gender = newUser.Gender;
                user.DateOfBirth = newUser.DateOfBirth;
                user.ConcurrencyStamp = newUser.ConcurrencyStamp;
                await _userManager.UpdateAsync(user);
            }
            else
            {
                await _userManager.CreateAsync(newUser, hashedPassword);
                await _userManager.AddToRoleAsync(newUser, roleName);
            }
            //create user with identity

            /*
            await _unitOfWork.ApplicationUserRepository.InsertAsync(newUser);
            */
            await _unitOfWork.SaveChangesAsync();

            //send email verification
            var message = new EmailOtpEvent()
            {
                Email = request.Email,
                EmailOtp = emailOtp
            };
            await _publishEndpoint.Publish<EmailOtpEvent>(message);
        }


        public async Task<LoginResponse> LoginWithGoogle(string googleId, string email, string userAgent, string ipAddress)
        {
            User? user = await _unitOfWork.GetRepository<User>().FindAsync(p => p.Email == email);
            TokenResponse token;
            
            //User already exists
            if (user != null)
            {
                //User googleId is null, update googleId
                if (user.GoogleId == null)
                {
                    user.GoogleId = googleId;
                    await _userManager.UpdateAsync(user);
                }
                token = await _tokenService.GenerateTokens(user, userAgent, ipAddress);
                return new LoginResponse()
                {
                    AccessToken = token.AccessToken,
                    RefreshToken = token.RefreshToken,
                    Role = await _userManager.GetRolesAsync(user)
                };
            }
            var roleName = StringHelper.CapitalizeString("user");
            
            //Get role by identity role (_roleManager)
            var role = await _roleManager.FindByNameAsync(roleName);
            if (role == null)
            {
                throw new CoreException(StatusCodes.Status400BadRequest, "Role not found");
            }
            
            User newUser = new User()
            {
                UserName = email,
                Email = email,
                GoogleId = googleId,
                EmailConfirmed = false,
                CreatedBy = "System",
                LastUpdatedBy = "System"
            };
            
            await _userManager.CreateAsync(newUser);
            await _userManager.AddToRoleAsync(newUser, roleName);
            await _unitOfWork.SaveChangesAsync();
            
            token = await _tokenService.GenerateTokens(newUser, userAgent, ipAddress);
            return new LoginResponse()
            {
                AccessToken = token.AccessToken,
                RefreshToken = token.RefreshToken,
                Role = await _userManager.GetRolesAsync(newUser)
            };
        }


        public async Task Logout(Guid userId, string userAgent, string ipAddress)
        {
            User? user = await _unitOfWork.GetRepository<User>().FindAsync(p => p.Id == userId);
            
            if (user == null)
            {
                throw new CoreException(StatusCodes.Status400BadRequest, "User not found");
            }
            
            // var userToken = await _unitOfWork.ApplicationUserTokenRepository.GetUserAsync(p =>
            //     p.UserId.ToString() == StringConverterHelper.CapitalizeString(userId) &&
            //     p.LoginProvider == deviceId);
            //
            
            string hashUserAgent = HmacSHA256Hasher.Hash(StringHelper.NormalizeString(userAgent));
            string hashIpAddress = HmacSHA256Hasher.Hash(ipAddress);
            
            var userToken = await _unitOfWork.GetRepository<UserToken>()
                .FindAsync(p => p.UserId == userId 
                                && p.UserAgentHash == hashUserAgent 
                                && p.IpAddressHash == hashIpAddress);
            
            if (userToken == null)
            {
                throw new CoreException(StatusCodes.Status400BadRequest, "User token not found");
            }
            
            _unitOfWork.GetRepository<UserToken>().DeletePermanent(userToken);
            await _unitOfWork.SaveChangesAsync();
        }

        /*public async Task<bool> ValidateToken(ValidateTokenRequestModel request)
        {
            ApplicationUser user = await _userManager.FindByIdAsync(request.UserId);
            if (user == null)
            {
                throw new CoreException(StatusCodes.Status401Unauthorized, "User not found");
            }
            var userToken = await _unitOfWork.ApplicationUserTokenRepository.GetUserAsync(p =>
                p.UserId.ToString() == request.UserId &&
                p.LoginProvider == request.DevideId);
            if (userToken == null)
            {
                throw new CoreException(StatusCodes.Status401Unauthorized, "User token not found");
            }
            if (String.CompareOrdinal(userToken.ExpiryTime, TimeStampHelper.GenerateUnixTimeStamp()) < 0)
            {
                throw new CoreException(StatusCodes.Status401Unauthorized, "Token expired");
            }
            string inputString = $"{request.UserId}{request.DevideId}{userToken.Value}";
            return _tokenService.ValidTokenHash(request.TokenHashed, inputString);
        }*/
        
        public async Task<UserContextResponse> GetUserContext(IHttpContextAccessor httpContextAccessor)
        {
            var context = httpContextAccessor.HttpContext;
            var ipAddress = context.Connection.RemoteIpAddress?.ToString();
            
            if (context.Request.Headers.ContainsKey("X-Forwarded-For"))
            {
                ipAddress = context.Request.Headers["X-Forwarded-For"].FirstOrDefault()?.Split(',').FirstOrDefault()?.Trim();
            }

            if (String.IsNullOrWhiteSpace(ipAddress))
            {
                throw new CoreException(StatusCodes.Status400BadRequest, "IP address not found");
            }
            var userAgent = context.Request.Headers["User-Agent"].ToString();
            
            if (String.IsNullOrWhiteSpace(userAgent))
            {
                throw new CoreException(StatusCodes.Status400BadRequest, "User-Agent not available");
            }
            
            return new UserContextResponse
            {
                IpAddress = ipAddress,
                UserAgent = userAgent
            };
        }
    }
}
